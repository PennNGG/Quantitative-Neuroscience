function [fits_,cis_,stats_,preds_,resids_,data_,pcor_] = ...    ctPsych_fit(fun,data,pcor,th_args,ci_args,init,setv,usePS,varargin)%function [fits_,cis_,stats_,preds_,resids_,data_,pcor_] = ...%    ctPsych_fit(fun,data,pcor,th_args,ci_args,init,setv,varargin)%% CTPSYCH_FIT fits a given model ("fun") to psychometric data --%   as a function of BOTH motion coherence (c) and viewing time (t) --%   using maximum likelihood maximization. 'fun' is the name or index of%   a supplied function for computing the underlying decision variable%% 	Input values are:%     fun  ... function handle. see ddFun%     data, rows are trials, columns are 'fun'-specific, but typically:%		   data(1) = coh  (0 ... 1)%          data(2) = time (fractional seconds)%          data(3) = <OPTIONAL> dot dir: left (-1) / right (1) / 0%          data(4) = <OPTIONAL> choice: left (-1) / right (1)%     pcor ... rows are trials, columns are:%          pcor(1) = pct or correct (1) / error (0)%          pcor(2) = (optinal) n%     th_args ... parameters used to compute threshold: {frac_correct view_time}%     ci_args ... cell array indicating how to compute confidence intervals%                   on the fit parameters:%                   {<n> <ci> <abs>}%     init ... optional array of initial values. Otherwise given%                   by 'fun'%     setv ... optional list of [fit_index fit_val] pairs to set, not fit%     usePS ... flag to start with patternSearch%     varargin ... extra args to send to ctPsych_fit%% 	Return values are:%     fits_   ... fun-specific%     cis_    ... Confidence intervals of the fits. Approximated using the%                   numerical HESSIAN returned by fmincon (default)%     stats_  ... [fitLLR Deviance Average_deviance p]%                   fitLLR is the log likelihood of obtaining the%                       data given the fit (returned by quick_err)%                   Deviance is 2(dataLLR - fitLLR) = -2*fitLLR%                   Average_deviance is Deviance./n. duh.%                   p is probability from chi^2 pdf with df = #blocks-3%     preds_  ... A vector of the probability of making a correct choice given%                   the fit%     resids_ ... col 1: outcome deviance residuals (see below)%                     2: outcome direct residuals%                     3: choice deviance residuals%                     4: choice direct residuals% Copyright 2005 by Joshua I. Gold%   University of Pennsylvania%% Created by jig 9/29/05if nargin < 1 || isempty(data)    returnendif nargin < 2 || isempty(fun)    fun = @ddExp3;elseif ischar(fun)    fun = str2func(fun);end% check for nan datafor cc = 1:size(data,2)    Lnan = isnan(data(:,cc));    if any(Lnan)        data(Lnan,:) = [];    endend% Check data column ... if data is only two%   columns (coh and time), remove 0% coh trials%   from fitting, since % correct at 0% coh is%   meaningless. Be careful to replace later %   (in preds_ and resids_)...% However, if third (dot dir) and fourth (choice)%   columns are given in data, recode 0% coh trials%   as all RIGHT dirs and correct/error based on choicedcol = size(data,2)>=2 && all(ismember(data(:,end),-1:1));L0   = data(:,1) == 0;if dcol    % possibly make choice array, if there are NOT    %   TWO end columns of [-1,0,1]    if all(ismember(data(:,end-1),-1:1))        chc  = data(:,end);        data = data(:,1:end-1); % strip choices    else        chc  = data(:,end).*(pcor(:,1)*2-1);    end    if any(L0)        Lrt = chc == 1;       % select RIGHT CHOICES        pcor(L0& Lrt, 1) = 1; % 0% coh, rt choices are CORRECT        pcor(L0&~Lrt, 1) = 0; % 0% coh, lt choices are ERRORS        data(L0, end)    = 1; % ALL 0% coh are RIGHT DIRS        L0(:)            = false; % for later    endelseif any(data(:,1)<0)    L0 = false(size(L0));end% check for n=0 in pcorif size(pcor,2) == 2 && any(pcor(:,2)==0)    L0 = L0 | pcor(:,2) == 0;end% remove bad rowsdata = data(~L0, :);pcor = pcor(~L0, :);   % check vararginif ~isempty(varargin)    varargin(nargin(fun)-1:end) = [];end% get initial values, bounds from fun%  send in data appended with pcorinits = feval(fun, [], [data pcor], varargin{:});% possibly replace initial values with argumentif nargin > 5    if length(init) == size(inits,1)        inits(:,1) = init(:);    elseif length(init) < size(inits,1)        inits(1:length(init)) = init(:);    endendif nargin > 6    for ss = 1:size(setv,1)        inits(setv(ss,1),:) = setv(ss,2);    endend% Fit using an in-line function added by jig 1/5/18myFun = @(x)ctPsych_err(x, fun, data, pcor, varargin{:});% use pattern search firstif nargin > 7 && usePS    errF = str2func('ctPsych_err');    inits(:,1) = patternsearch(myFun, ...        inits(:,1), [], [], [], [], inits(:,2), inits(:,3), [], ...        psoptimset('MaxIter', 8000, 'MaxFunEvals', 8000));end% now fit using gradient descent[fits,f,e,o,l,g,H] = fmincon(myFun, ...    inits(:, 1), [], [], [], [], inits(:, 2), inits(:, 3), [], ...    optimset('LargeScale', 'off', 'Algorithm', 'active-set', ...    'Display', 'off', 'Diagnostics', 'off', ...    'FunValCheck', 'on')); %, fun, data, pcor, varargin{:});% get predictions, which we might use for semspreds = feval(fun, fits, data, varargin{:});% compute thresholdfits_ = fits;if nargin > 3 && iscell(th_args)    if isempty(th_args)        pctc   = 0.8161; % from Weibull        vtime  = 1.0;    % seconds    elseif length(th_args) == 1        pctc   = th_args{1};        vtime  = 1.0;    else        pctc   = th_args{1};        vtime  = th_args{2};    end    fits_(end+1) = ctPsych_thresh(fun, fits, pctc, vtime);endif nargout > 1    % confidence intervals    if nargin < 5 || ~iscell(ci_args)        % Compute Standard errors        %   The covariance matrix is the negative of the inverse of the        %   hessian of the natural logarithm of the probability of observing        %   the data set given the optimal parameters.        %   For now, use the numerically-estimated HESSIAN returned by fmincon        %   (which remember is computed from -log likelihood)        % -H because we used -logL in quick_err        cis_ = sqrt(diag(-((-H)^(-1))));            else        % citype is cell array with:        %   number of simulated data sets to create        %   confidence interval        if isempty(ci_args)            ci_args = {[], []};        end        % Check for input etype, which indicates that we will use        %    Monte Carlo resampling (parametric bootstrap).        %   See Wichmann & Hill (2001)        %       The psychometric function: II. Bootstrap-        %           based confidence intervals and sampling        % citype{1} is number of simulated data sets to use        if isempty(ci_args{1})            mcn = 100;        else            mcn = ci_args{1};        end                % jig added 5/14/14        % maybe convert fits to absolute values        if length(ci_args)>2 && ~isempty(ci_args{3})            fits(ci_args{3}) = abs(fits(ci_args{3}));                        fits_(ci_args{3}) = abs(fits_(ci_args{3}));        end        if mcn > 0            if size(pcor,2) == 1                ns = ones(size(pcor,1),1);            else                ns = pcor(:,2);            end            mcfits = zeros(mcn, length(fits_));            for ii = 1:mcn                if ~mod(ii,50)                    disp(sprintf('Bootstrap CIs, set %d', ii))                end                % compute fit on simulated data set                                mcfit = fmincon('ctPsych_err', ...                    fits, [], [], [], [], inits(:,2), inits(:,3), [], ...                    optimset('LargeScale', 'off', 'Algorithm', 'active-set', ...                    'Display', 'off', 'Diagnostics', 'off', ...                    'FunValCheck', 'on'), fun, data, ...                    [binornd(ns,preds)./ns ns], varargin{:});                                % jig added 5/14/14                % maybe convert fits to absolute values                if length(ci_args)>2 && ~isempty(ci_args{3})                    mcfit(ci_args{3}) = abs(mcfit(ci_args{3}));                end                % possibly compute threshold                if length(fits_) > length(fits)                    mcfit = [mcfit; ctPsych_thresh(fun, mcfit, pctc, vtime)];                end                mcfits(ii,:) = mcfit;            end            % ci_args{2} is confidence interval            %   'sem' is 68            %   'iqr' is 50            %   90 is default            if length(ci_args) < 2 || isempty(ci_args{2})                CI = 90; % confidence interval            elseif ischar(ci_args{2})                switch ci_args{2}                    case 'sem'                        CI = 68;                    case 'iqr'                        CI = 50;                    otherwise                        CI = 90;                end            elseif isscalar(ci_args{2})                CI = ci_args{2};            end            cis_ = [prctile(mcfits,50-CI/2)' prctile(mcfits,50+CI/2)'];        else            cis_ = [];        end    endend% return statsif nargout > 2    % The err function returns -M (from Watson, 1979).    % This is related to the log likelihood of the fits    %   by an offset term that does not depend on the predicted     %   p's; specifically, sum(log(n-choose-k)):    M1    = -ctPsych_err(fits, fun, data, pcor, varargin{:});    if size(pcor,2) > 1        k      = round(pcor(:,1).*pcor(:,2));        offset = zeros(size(k));        for oo = 1:length(offset)            offset(oo) = log(nchoosek(pcor(oo,2), k(oo,2)));        end        logL = sum(offset) + M1;    else        logL = M1;    end                % deviance is 2(M0 - M1), where    % M0 is the log likelihood of the data ("saturated model").    %   If n=1 always, then M0 = 0    %   If n>1 in any case, then    %       M0 = sum( n_i .* (x_i.*log(x_i) + (1-x_i).*log(1-x_i) ))    if size(pcor,2) > 1        M0 = sum(pcor(:,2).*(pcor(:,1).*log(pcor(:,1))+(1-pcor(:,1)).*log(1-pcor(:,1))));    else        M0 = 0;    end    dev = 2*(M0 - M1);    % average deviance    adev = dev./size(data, 1);    % probability is from cdf    p = 1 - chi2cdf(dev, size(data, 1) - size(fits, 1));    stats_ = [M1 logL dev adev p];end% return the predicted probability (of a correct response) for %   each observation again using only first fitif nargout > 3    % check if we stripped 0% coh trials    if any(L0)        preds_      = 0.5*ones(size(L0));        preds_(~L0) = preds;    else        preds_ = preds;    endend% return the deviance residuals ... these are the square roots%   of each deviance computed individually, signed according to%   the direction of the arithmatic residual y_i - p_i.% See Wichmann & Hill, 2001, "The psychometric function: I. Fitting,%   sampling, and goodness of fit", eqs. 11 and 12.if nargout > 4    % useful selection arrays    Lcor = pcor(:,1) == 1;    Lerr = pcor(:,1) == 0;    % avoid p=0,1 for deviance calculations    TINY              = 0.0001;    dpreds            = preds_;    dpreds(dpreds==0) = TINY;    dpreds(dpreds==1) = 1 - TINY;    % first column is residual deviance for outcome    %  correct trials =  sqrt(-2 * log(p))    %  error trials   = -sqrt(-2 * log(1-p))    rdo       = dpreds;    rdo(Lerr) = 1 - rdo(Lerr);    rdo       = (pcor(:,1)*2-1).*sqrt(-2*log(rdo));    % second column is direct residual for outcome    %  correct trials = 1 - p;    %  error trials   = -p;    rro       = preds_;    rro(Lcor) = 1 - rro(Lcor);    rro(Lerr) = -rro(Lerr);    % Third and fourth columns are based on CHOICE --    %   only compute if third column of data is given,    %   listing dot directions per trial    if dcol                % selection arrays for left/right DIRS        Llt  = data(:,end) == -1;        Lrt  = data(:,end) == 1;                % third column is residual deviance for choice;        %   here we 'flip' p for leftward dots        %   xY is x dir, Y choice        %   rR = sqrt(-2*log(p))        %   rL = -sqrt(-2*log(1-p))        %   lR = sqrt(-2*log(1-p))        %   lL = -sqrt(-2*log(p))        rdc           = sqrt(-2*log(dpreds));        rdcMP         = sqrt(-2*log(1-dpreds));        rdc(Lerr&Lrt) = -rdcMP(Lerr&Lrt);        rdc(Lerr&Llt) = rdcMP(Lerr&Llt);        rdc(Lcor&Llt) = -rdc(Lcor&Llt);        % fourth column is direct residual for choice        %   rR = 1 - p        %   rL = -p        %   lR = p        %   lL = -(1 - p) = p - 1        rrc = preds_;        rrc(Lcor&Lrt) = 1 - rrc(Lcor&Lrt);        rrc(Lerr&Lrt) = -rrc(Lerr&Lrt);        rrc(Lcor&Llt) = rrc(Lcor&Llt) - 1;                resids_ = [rdo rro rdc rrc];    else        % not computed by choice        % first check for 0% coh trials -- resids        %   should be nan        if any(L0)            resids_ = nans(size(L0,1), 2);            resids_(~L0, 2) = [rdo rro];                  else            resids_ = [rdo rro];        end    end    endif nargout > 5    data_ = data;endif nargout > 6    pcor_ = pcor;end